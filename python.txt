import asyncio
import json
import os
import pygame
import requests
import RPi.GPIO as GPIO
import websockets
from Adafruit_ADS1x15 import ADS1115

pygame.mixer.init()

button_pins = [5, 6, 13, 19, 26, 16, 20, 21, 4, 17, 27, 22, 24, 25, 23, 18]
assigned_sounds = {pin: None for pin in button_pins}
sound_files = {}
playing_sounds = {}
button_pressed = {pin: False for pin in button_pins}
connected_clients = set()

# Set I2C bus number
I2C_BUS_NUM = 1
# Create an ADS1115 ADC object at address 0x48
adc = ADS1115(address=0x48, busnum=I2C_BUS_NUM)
# Set the gain to Â±4.096V (adjust if needed)
GAIN = 1

async def handle_message(websocket, path):
    global connected_clients, sound_files, playing_sounds
    connected_clients.add(websocket)
    sound_files = {}  # Reset sound_files dictionary when a new client connects
    playing_sounds = {}  # Reset playing_sounds dictionary when a new client connects
    assigned_sounds = {pin: None for pin in button_pins}  # Reset assigned sounds when a new client connects
    try:
        print("Client connected:", websocket.remote_address)
        async for message in websocket:
            print("Received message:", message)
            data = json.loads(message)
            if data['type'] == 'assign_sound':
                pin = data['pin']
                sound = data['sound']
                if assigned_sounds[pin] != sound:
                    assigned_sounds[pin] = sound
                    await download_sound(pin, sound)
                    await broadcast_assigned_sounds()
    except websockets.exceptions.ConnectionClosedError:
        print("Client disconnected:", websocket.remote_address)
        pass
    finally:
        connected_clients.remove(websocket)

async def broadcast_assigned_sounds():
    global connected_clients
    await asyncio.gather(
        *[ws.send(json.dumps({'type': 'assigned_sounds', 'sounds': assigned_sounds})) for ws in connected_clients]
    )

async def download_sound(pin, sound):
    global sound_files
    sound_url = sound['previews']['preview-hq-mp3']
    sound_file_path = f"sound_{pin}.mp3"

    if os.path.exists(sound_file_path):
        os.remove(sound_file_path)

    response = requests.get(sound_url)
    if response.status_code == 200:
        with open(sound_file_path, 'wb') as f:
            f.write(response.content)
        
        sound_files[pin] = sound_file_path
    else:
        print(f"Failed to retrieve sound file from {sound_url}. Status code: {response.status_code}")

async def button_click(pin):
    global button_pressed
    if button_pressed[pin]:
        return
    button_pressed[pin] = True
    print(f"Button on pin {pin} clicked")
    if pin in playing_sounds:
        playing_sounds[pin].stop()
        del playing_sounds[pin]
    await play_sound(pin)
    if sound_files.get(pin):  # Check if there's a sound assigned to this button
        await broadcast_button_click(pin)

async def play_sound(pin):
    global sound_files, playing_sounds
    
    sound_file_path = sound_files.get(pin)
    if sound_file_path:
        sound = pygame.mixer.Sound(sound_file_path)
        
        # Apply distortion effect based on the potentiometer value
        raw_distortion_value = adc.read_adc(2, gain=GAIN)
        percent_distortion_value = round((raw_distortion_value / 26362) * 100)
        distortion_level = percent_distortion_value - 50  # Center at 50
        
        sound.set_volume(1.0)  # Reset volume
        
        # Apply distortion effect
        sound.set_volume(max(0, min(1.0, 1.0 + (distortion_level / 100.0))))
        
        # Apply reverb effect based on the potentiometer value
        raw_reverb_value = adc.read_adc(3, gain=GAIN)
        percent_reverb_value = round((raw_reverb_value / 26362) * 100)
        reverb_level = percent_reverb_value - 50  # Center at 50
        
        # Apply reverb effect
        sound.set_volume(max(0, min(1.0, 1.0 + (reverb_level / 100.0))))
        
        # Play the sound
        sound.play()
        
        playing_sounds[pin] = sound



async def button_release(pin):
    global button_pressed
    button_pressed[pin] = False

async def detect_button_clicks():
    GPIO.setmode(GPIO.BCM)
    for pin in button_pins:
        GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    
    while True:
        for pin in button_pins:
            if GPIO.input(pin) == GPIO.LOW:
                await button_click(pin)
                while GPIO.input(pin) == GPIO.LOW:
                    await asyncio.sleep(0.01)
                await button_release(pin)
        await asyncio.sleep(0.01)

async def read_potentiometer():
    # Initialize previous values for distortion and reverb
    prev_distortion_value = None
    prev_reverb_value = None
    
    while True:
        # Read the raw analog value from channel A2 for distortion
        raw_distortion_value = adc.read_adc(2, gain=GAIN)
        # Scale the raw value to a percentage (0-100)
        percent_distortion_value = round((raw_distortion_value / 26362) * 100)
        
        # Read the raw analog value from channel A3 for reverb
        raw_reverb_value = adc.read_adc(3, gain=GAIN)
        # Scale the raw value to a percentage (0-100)
        percent_reverb_value = round((raw_reverb_value / 26362) * 100)
        
        # Check if distortion value changed by 5% or more
        if prev_distortion_value is None or abs(percent_distortion_value - prev_distortion_value) >= 5:
            # Broadcast the distortion value to all connected clients
            await broadcast_potentiometer_value('distortion', percent_distortion_value)
            # Update previous distortion value
            prev_distortion_value = percent_distortion_value
        
        # Check if reverb value changed by 5% or more
        if prev_reverb_value is None or abs(percent_reverb_value - prev_reverb_value) >= 5:
            # Broadcast the reverb value to all connected clients
            await broadcast_potentiometer_value('reverb', percent_reverb_value)
            # Update previous reverb value
            prev_reverb_value = percent_reverb_value
        
        # Delay for a short interval before reading again
        await asyncio.sleep(1)

async def broadcast_potentiometer_value(potentiometer_type, value):
    global connected_clients
    message = json.dumps({
        'type': 'potentiometer_value',
        'potentiometer_type': potentiometer_type,
        'value': value
    })
    await asyncio.gather(
        *[ws.send(message) for ws in connected_clients]
    )

async def main():
    await asyncio.gather(
        websockets.serve(handle_message, "0.0.0.0", 8765),
        detect_button_clicks(),
        read_potentiometer()
    )

async def broadcast_button_click(pin):
    global connected_clients
    
    await asyncio.gather(
        *[ws.send(json.dumps({'type': 'button_click', 'pin': pin})) for ws in connected_clients]
    )

async def preload_sound_files():
    for pin, sound in assigned_sounds.items():
        if sound:
            await download_sound(pin, sound)

asyncio.run(preload_sound_files())
asyncio.run(main())
