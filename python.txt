import asyncio
import json
import os
import pygame
import requests
import RPi.GPIO as GPIO
import websockets
from Adafruit_ADS1x15 import ADS1115
import numpy as np
from pysndfx import AudioEffectsChain

# Initialize Pygame mixer
pygame.mixer.init(frequency=44100, size=-16, channels=2)

button_pins = [5, 6, 13, 19, 26, 16, 20, 21, 4, 17, 27, 22, 24, 25, 23, 18]
assigned_sounds = {pin: None for pin in button_pins}
sound_files = {}
playing_sounds = {}
button_pressed = {pin: False for pin in button_pins}
connected_clients = set()
distortion_value = 0
reverb_value = 0

# Set I2C bus number
I2C_BUS_NUM = 1
# Create an ADS1115 ADC object at address 0x48
adc = ADS1115(address=0x48, busnum=I2C_BUS_NUM)
# Set the gain to Â±4.096V (adjust if needed)
GAIN = 1

async def handle_message(websocket):
    global connected_clients, sound_files, playing_sounds, assigned_sounds, distortion_value, reverb_value
    connected_clients.add(websocket)
    sound_files = {}  # Reset sound_files dictionary when a new client connects
    playing_sounds = {}  # Reset playing_sounds dictionary when a new client connects
    assigned_sounds = {pin: None for pin in button_pins}  # Reset assigned sounds when a new client connects
    try:
        print("Client connected:", websocket.remote_address)
        distortion_value = 0
        reverb_value = 0
        async for message in websocket:
            print("Received message:", message)
            data = json.loads(message)
            if data['type'] == 'assign_sound':
                pin = data['pin']
                sound = data['sound']
                if assigned_sounds[pin] != sound:
                    assigned_sounds[pin] = sound
                    await download_sound(pin, sound)
                    await broadcast_assigned_sounds()
            elif data['type'] == 'reverb':
                # Handle incoming reverb value update
                reverb_value = data['value']
                print("Received reverb value:", reverb_value)
                # Implement logic to update reverb value processing here
            elif data['type'] == 'distortion':
                # Handle incoming distortion value update
                distortion_value = data['value']
                print("Received distortion value:", distortion_value)
                # Implement logic to update distortion value processing here
    except websockets.exceptions.ConnectionClosedError:
        print("Client disconnected:", websocket.remote_address)
        pass
    finally:
        connected_clients.remove(websocket)



async def broadcast_assigned_sounds():
    global connected_clients
    await asyncio.gather(
        *[ws.send(json.dumps({'type': 'assigned_sounds', 'sounds': assigned_sounds})) for ws in connected_clients]
    )

async def download_sound(pin, sound):
    global sound_files
    sound_url = sound['previews']['preview-hq-mp3']
    sound_file_path = f"sound_{pin}.mp3"

    if os.path.exists(sound_file_path):
        os.remove(sound_file_path)

    response = requests.get(sound_url)
    if response.status_code == 200:
        with open(sound_file_path, 'wb') as f:
            f.write(response.content)
        
        sound_files[pin] = sound_file_path
    else:
        print(f"Failed to retrieve sound file from {sound_url}. Status code: {response.status_code}")

async def button_click(pin):
    global button_pressed, adc

    if button_pressed[pin]:
        return

    button_pressed[pin] = True
    print(f"Button on pin {pin} clicked")

    # Read the raw analog value from the reverb potentiometer channel (A3)
    raw_reverb_value = adc.read_adc(3, gain=GAIN)
    percent_reverb_value = round((raw_reverb_value / 26362) * 100)

    # Read the raw analog value from the distortion potentiometer channel (A2)
    raw_distortion_value = adc.read_adc(2, gain=GAIN)
    percent_distortion_value = round((raw_distortion_value / 26362) * 100)

    if pin in playing_sounds:
        playing_sounds[pin].stop()
        del playing_sounds[pin]

    await play_sound(pin)

    if sound_files.get(pin):
        await broadcast_button_click(pin)

        
def adjust_reverb_level(percent_reverb_value):
    # Apply a nonlinear scaling function to compress the range of lower values more aggressively
    scaled_reverb_level = (percent_reverb_value / 100.0) ** 2  # Example nonlinear scaling function
    return scaled_reverb_level
        
async def apply_reverb(sound_array, reverb_level):
    # Apply a spatial reverb effect
    # You can adjust the reverb level and decay time for different effects
    decay = 0.5  # Adjust the decay time of the reverb effect
    reverb_samples = int(44100 * decay)
    reverb = np.zeros_like(sound_array)

    for i in range(reverb_samples, len(sound_array)):
        reverb[i] = sound_array[i - reverb_samples] * reverb_level

    # Mix the original sound with the reverb effect
    sound_with_reverb = sound_array + reverb
    
    if reverb_level < 0.5:
        sound_with_reverb *= 0.4

    return sound_with_reverb

async def play_sound(pin):
    global sound_files, playing_sounds, adc, reverb_value, distortion_value

    sound_file_path = sound_files.get(pin)
    if sound_file_path:
        # Load the sound file
        sound = pygame.mixer.Sound(sound_file_path)
        sound_array = pygame.sndarray.array(sound).astype(np.float32) / 32767.0  # Normalize to [-1, 1]
        
        # Ensure the array matches the mixer channels
        mixer_channels = pygame.mixer.get_init()[2]
        if len(sound_array.shape) == 1 and mixer_channels == 2:
            # Mono to stereo
            sound_array = np.stack([sound_array, sound_array], axis=-1)
        elif len(sound_array.shape) == 2 and sound_array.shape[1] != mixer_channels:
            # Stereo to mono or incorrect stereo
            if mixer_channels == 1:
                sound_array = sound_array.mean(axis=1)
            else:
                sound_array = np.stack([sound_array.mean(axis=1)] * mixer_channels, axis=-1)
        
        # Apply distortion effect if the distortion level is above 0
        if distortion_value > 0:
            distortion_level = distortion_value / 100  # Scale to [0, 1]
            print("Distortion level:", distortion_level)
            sound_array = np.clip(sound_array * (1 + distortion_level * 10), -1, 1)  # Increase distortion effect
        
        # Convert back to int16 for pygame sound
        sound_array_int16 = (sound_array * 32767).astype(np.int16)
        sound_array_int16 = np.ascontiguousarray(sound_array_int16)  # Ensure the array is C-contiguous
        
        # Create and play the processed sound
        processed_sound = pygame.sndarray.make_sound(sound_array_int16)
        processed_sound.play()
        
        playing_sounds[pin] = processed_sound
        
        # Apply reverb effect if the reverb level is above 0
        if reverb_value > 0:
            reverb_level = reverb_value / 100.0  # Scale to [0, 1]
            sound_array_with_reverb = await apply_reverb(sound_array, reverb_level)
            
            # Convert back to int16 for pygame sound
            sound_array_with_reverb_int16 = (sound_array_with_reverb * 32767).astype(np.int16)
            sound_array_with_reverb_int16 = np.ascontiguousarray(sound_array_with_reverb_int16)  # Ensure the array is C-contiguous
            
            # Create and play the processed sound with reverb
            processed_sound_with_reverb = pygame.sndarray.make_sound(sound_array_with_reverb_int16)
            processed_sound_with_reverb.play()
            
            playing_sounds[pin] = processed_sound_with_reverb



async def button_release(pin):
    global button_pressed
    button_pressed[pin] = False

async def detect_button_clicks():
    GPIO.setmode(GPIO.BCM)
    for pin in button_pins:
        GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    
    while True:
        for pin in button_pins:
            if GPIO.input(pin) == GPIO.LOW:
                await button_click(pin)
                while GPIO.input(pin) == GPIO.LOW:
                    await asyncio.sleep(0.01)
                await button_release(pin)
        await asyncio.sleep(0.01)

async def read_potentiometer():
    global distortion_value, reverb_value
    # Initialize previous values for distortion and reverb
    prev_distortion_value = None
    prev_reverb_value = None
    
    while True:
        # Read the raw analog value from channel A2 for distortion
        raw_distortion_value = adc.read_adc(2, gain=GAIN)
        # Scale the raw value to a percentage (0-100)
        percent_distortion_value = round((raw_distortion_value / 26362) * 100)
        
        # Read the raw analog value from channel A3 for reverb
        raw_reverb_value = adc.read_adc(3, gain=GAIN)
        # Scale the raw value to a percentage (0-100)
        percent_reverb_value = round((raw_reverb_value / 26362) * 100)
        
        # Check if distortion value changed by 5% or more
        if prev_distortion_value is None or abs(percent_distortion_value - prev_distortion_value) >= 5:
            # Broadcast the distortion value to all connected clients
            await broadcast_potentiometer_value('distortion', percent_distortion_value)
            # Update previous distortion value
            distortion_value = percent_distortion_value
            prev_distortion_value = percent_distortion_value
        
        # Check if reverb value changed by 5% or more
        if prev_reverb_value is None or abs(percent_reverb_value - prev_reverb_value) >= 5:
            # Broadcast the reverb value to all connected clients
            await broadcast_potentiometer_value('reverb', percent_reverb_value)
            # Update previous reverb value
            reverb_value = percent_reverb_value
            prev_reverb_value = percent_reverb_value
        
        # Delay for a short interval before reading again
        await asyncio.sleep(1)

async def broadcast_potentiometer_value(potentiometer_type, value):
    global connected_clients
    message = json.dumps({
        'type': 'potentiometer_value',
        'potentiometer_type': potentiometer_type,
        'value': value
    })
    await asyncio.gather(
        *[ws.send(message) for ws in connected_clients]
    )

async def main():
    await asyncio.gather(
        websockets.serve(handle_message, "0.0.0.0", 8765),
        detect_button_clicks(),
        read_potentiometer()
    )

async def broadcast_button_click(pin):
    global connected_clients
    
    await asyncio.gather(
        *[ws.send(json.dumps({'type': 'button_click', 'pin': pin})) for ws in connected_clients]
    )

if __name__ == "__main__":
    asyncio.run(main())